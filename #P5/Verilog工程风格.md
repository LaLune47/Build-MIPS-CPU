# Verilog工程风格

- **需求分析：**使用文档辅助工具协同进行架构设计

- 需求实现：

  根据设计文档高效完成模块代码编写

  - 编写代码
  - 关注代码风格
  - 浅谈编辑器

- 仿真与调试：

  对已有模块进行测试

  - 生成 Testbench
  - 使用 ISim
  - 错误样例







## 规范化编码

**命名风格**

在对模块，尤其是流水寄存器这样具有大量端口的关键部件进行设计时，规范化的命名便能体现出其重要性。

例如，如果你的设计中的指令需要随着各级进行流水，各级的流水寄存器的输入输出端口均会出现相同的信号，在对工程进行调试时，如果每一级的指令端口信号均采取相同的命名，很可能会产生混淆，导致 Bug 产生。因此，可以使用`流水级_instr_方向`的方式，来有效地对它们进行区分，D/E 寄存器的输入端口就可以命名为 D_instr_i。

再举个例子，在顶层模块，我们需要实例化调用子模块，这个过程会产生很多负责接线的“中间变量”。非常不建议使用“ temp ”这类不明确的字眼对中间变量进行命名，依然推荐`流水级_wirename`的方式，并且将同级的信号尽可能都声明在一起。

**模块逻辑排布**

对模块内部逻辑编写时，将==组合逻辑、时序逻辑==明确分隔开，

一些中间变量可以在模块端口定义下方统一声明，==也可以在对应逻辑的上方紧邻声明==，尽量避免声明位置与赋值语句位置混乱交叉。

流水线 CPU 相比单周期 CPU，顶层增加了流水寄存器以及相关的所有端口连线信号，复杂度与代码量有了明显的升高。

ISE 的 Design 栏能够按照顺序显示调用的子模块实例，在设计时，可以利用这一点，按照流水级的顺序对每一级的流水寄存器进行实例化，==然后在其间插入相应级的模块==，并用注释清晰地注明各级起始位置。另外，也可以考虑**增加模块层次**，将每一流水级的各个模块放入一个父级模块中调用，可以将复杂度有效分散到各个层级。

![image-20211203083022390](C:\Users\28728\AppData\Roaming\Typora\typora-user-images\image-20211203083022390.png)

**常量、字面量与宏**

我们无论是在控制器解码指令的 op 或者 rs 字段，还是在使用某个模块的操作信号对功能进行选择时，都不可避免地需要使用到常量或字面量。如果直接使用 instr[31:26]、4'd2 等数字来表示，会给阅读和调试带来不小的阻碍。尤其是当这个值需要被频繁引用或者在增量开发要发生变动时，编写者很容易因为一个地方的疏忽而写出 Bug。为了解决这个问题，推荐下面的做法。

对于指令不同的字段，直接定义 wire 型变量如 op、rs 映射到 instr 的对应位上，直观且简短。

对于控制器译出的信号，如果仅在一个模块内使用，可以使用 localparam 定义。但有很多信号需要被多个模块跨文件使用到（如 alu 的控制信号需要同时在控制器与 alu 出现），并且，我们需要为工程的扩展做好准备，因此更推荐编写一个单独的**宏定义文件**来供其他的模块用 `include 引用。

![image-20211203083129214](C:\Users\28728\AppData\Roaming\Typora\typora-user-images\image-20211203083129214.png)

**控制器设计**

面对复杂的工程，我们会有多种方式对指令进行译码，下面将介绍主流的两种译码方式与两种译码风格，引导大家对其进行思考并作出适合自己的设计。

**译码方式**

- **集中式译码**：在取指令（ F 级）时或者读取寄存器阵列信息（ D 级）前，将所有的控制信号全部解析出，然后让其随着流水往后逐级传递。使用这种方法，只需要在初始对指令进行一次译码，减少了后续流水级的逻辑复杂度，但流水级之间需要传递的信号数量很大。
- ==**分布式译码**==：每一级都部署一个控制器，负责译出当前级所需控制信号。这种方法较为灵活，“现译现用”有效降低了流水级间传递的信号量，但是需要实例化多个控制器，增加了后续流水级的逻辑复杂度。

**译码风格**

- **指令驱动型**：整体在一个 case 语句之下，通过判断指令的类型，来对所有的控制信号一一进行赋值。这种方法便于指令的添加，不易遗漏控制信号，但是整体代码量会随指令数量增多而显著增大。

  ![image-20211203083244596](C:\Users\28728\AppData\Roaming\Typora\typora-user-images\image-20211203083244596.png)

  如果重复部分太多，非常不推荐复制粘贴的做法，可以尝试用宏将其抽象出来。

- **控制信号驱动型**：为每个指令定义一个 wire 型变量，使用或运算描述组合逻辑，对每个控制信号进行单独处理。这种方法在指令数量较多时适用，且代码量易于压缩，缺陷是如错添或漏添了某条指令，很难锁定出现错误的位置。

  ![image-20211203083328611](C:\Users\28728\AppData\Roaming\Typora\typora-user-images\image-20211203083328611.png)





