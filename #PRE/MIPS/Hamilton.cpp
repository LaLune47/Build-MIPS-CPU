1.算法的C语言实现
? C语言是比较接近汇编的语言，先从C语言的代码开始考虑这个题目。网上关于哈密顿回路的介绍其实不多，这主要是因为这个问题仍然是未解的（尚且未找到其对应的充要条件）。

? 按照百度的定义，可以形象的理解为在图中找到一条线路把所有点串成环，从算法实现的角度来看就是指从一个顶点出发遍历完所有顶点后回到原顶点，而遍历所有顶点的算法是上个学期图里的DFS算法。

? 所以这里先给出遍历所有顶点的C语言代码:

int adj[10][10];//邻接矩阵，adj[i][j]表示i->j存在路径 adj[j][i]表示j->i存在路径
int flag[10];//标记
void judge(int now,int num)//判断是否存在遍历完所有顶点的路线 now-当前位置 num-已经遍历的顶点数用ans的值表示是否存在
int n;//n-顶点数
int ans;
int main()
{
    pre();//指预处理，读入顶点数，边数，邻接表的赋值等等，这里略去
    int i;
    for(i=0;i<n;i++)
        judge(i,1);//视为i已经被访问
    return 0;
}

void judge(int now,int num)
{
    if(num == n)
        ans = 1;//遍历的次数达到n，就意味着所有点被遍历
    //但这不代表他们成环
    flag[now] = 1; //标记已走
    int i;
    if(num == n)
    for(i=0;i<n;i++)
    { 
        if(flag[i]==0&&adj[now][i])//两点间有路
        judge(i,num+1) //到达了新的点 i
    }
     flag[now] = 0; //清除标记
}



? 以上就是遍历所有顶点的DFS实现，接下来考虑成环这一情况，成环意味着回到最开始的顶点，也就是说在 num == n时要多进行一次判断，但同样的就不得不保留一个重要量：从哪一个点开始。这里采用定义全局变量来实现，所以只需要微调上面的代码即可。这里把需要改动的地方写一写，不再重复代码。

int orginal;//一开始的点 等效代码全都省略
int main()
{
    for(;;)
    {
        orginal = i;
        judge(i,1)
    }
    return 0;
}
void judge(int now,int num)
{
    if(num == n&&adj[now][orginal]==1)
        ans = 1;
}
? 再考虑一个问题，如果成环，从哪一个点开始真的重要吗？

? 显然并不重要，如1-2-3-1和2-3-1-2完全等效。也就是说在主函数里的for循环并无用处可以直接用0来当初始点。这里看过输入的同学先不要着急，输入从1开始并不影响，只需要在读入时处理。

? 最后一个问题num这个变量可不可以略去，将它定义为全局变量即可。
