///////////////////////分支跳转类
///链接///
//无条件链接就非常简单，就像jal或是jalr那样链接就好，
//至于条件链接就要复杂一点，因为我们要根据  D_cmp  得到的b_j信号来决定是否链接，
//于是乎我们将该信号流水下去，
//并在E级,M级，W级将该信号连到ctrl里面做如下判断：   一定是要在每一个E,M,W都有判断，要不然影响转发（A3选择信号还是不能舍弃）
assign gwa_res = ...
    			(bgezal | bltzal)?((b_j)?5'd31: 5'b0 ):
				...	  

​//如果不链接我们就将pc + 8写入0号寄存器，因为写入0号寄存器的值不会被转发，同时也写不进去，所以不会产生任何有效行为，
//至于阻塞怎么办，将该类指令归入branch类指令或者像beq那样判断要用什么就好，
//大家课下可以加一下bltzal或者bgezal这两条指令集和mars有的指令，建议按mars中的条件链接来加（指令集中为无条件链接），加完后直接带到课上，这样课上连b_j流水都不用管了


////是否清空延迟槽////
// 描述一般是：就是不跳转的时候不执行下一条指令（延迟槽中的指令）而是执行下下条指令，

至于条件链接就要复杂一点，因为我们要根据D_cmp得到的b_j信号来决定是否链接，

//首先在mips.v的D级做一个判断，判断是否清延迟槽(以bonall这条指令为例)，
wire D_flush = bonall && !b_j;
//然后将其连到F到D级寄存器中，注意阻塞时不清延迟槽。
D_REG d_reg (
    .reset(reset| (D_flush && !stall)),  （d_reset = 0）








////条件访存类////
///主要也是两类，用M级的数据算出是否写寄存器，又或者是算出写哪个寄存器，
/// 全部归类于写哪个寄存器，如果不写就是写入0

//在M级通过计算得到了写入地址
//首先在M级获得控制信号：
//   在 M_dm里面得到一个控制信号如下：
		integer i;
		reg [31:0] o = 0;
		reg [31:0] z = 0;
		always@(*)begin
			o = 0;
			z = 0;
            for(i = 0; i < 16; i = i + 1)begin//hf为读出的半字
				if(hf[i] == 1'b1) o = o + 1;
				else z = z + 1;
			end
			if(o > z) lhonez_ch = 1'b1;
			else lhonez_ch = 1'b0;
		end

// 在M级已经得到了lhonez_ch信号(判断写入A3的种类)
//于是乎我认为在M级就知道了写入地址，
//可以将其连到M级ctrl里面，同时将该信号流水到W级里面并连到ctrl里面，
wire [4:0] lhonez_a = (lhonez_ch === 1'bz || lhonez_ch === 1'bx)? 0 : (lhonez_ch === 1'b1)? rt : 32'd31;
assign gwa_res = ...//grf写入地址
				(lhonez)? lhonez_a :
				 ...   
assign gwd_sel = ... //grf写入什么值
				(lhonez)?((lhonez_ch === 1'b1)? `gwd_dm : `gwd_pc4):
				...
//因此该信号的值会是z，于是我们用====判断，在E级或是D级时它写0号寄存器（因为不会产生任何影响），在这里暂时先不考虑阻塞问题。


//它如果写31那么就是写pc + 4，由于转发只有pc + 8因此这里必须要改改:
assign fw_E_wd = (E_gwd_sel == `gwd_pc8)? E_pc + 8:
				 (E_gwd_sel == `gwd_pc4)? E_pc + 4:
				 32'd0;   //(其他级别同理)




/////// 阻塞的关键 //////////////////////////////////////////////////
//就是说在M级前不知到写入地址，那么当该条指令在E级时要特判一下阻塞，\
//在M级就像正常的load类指令（将该类指令归入load类）用Tuse,Tnew判断就好了
​ //但是注意上面说的可能有bug,建议该指令在M级的时候也像E那样特判阻塞，严格来说不用， 
//  (就在阻塞这里反复试探发现特判时硬阻一个周期过不了，条件阻一个也过不了，硬阻两个只有一个点TLE了，于是条件阻两个周期就过了)
//​ 总之：建议特判条件阻两个周期
//下面代码就只条件阻了一个周期，再复制一遍，把E改成M就好了：
assign stall_lhonez = (E_lhonez && (((D_rs == E_rt || D_rs == 5'd31) && (D_rs != 5'd0) && (Tuse_rs < Tnew_E)) || ((D_rt == E_rt || D_rt == 5'd31) && (D_rs != 5'd0) && (Tuse_rt < Tnew_E))));
             // 是E级别，rs、rt阻塞的合并，M级改一下E\M就可以了

// 其他类别：
//然后是lwer这种需要用dm_out,rt_data计算地址的可以这样写(rt_d记得流水到W级)：
wire lwer_ch = lwer && mem_word && rt_d;
assign gwa_res = ...
                 (lwer)? ((lwer_ch !== 1'bz && lwer_ch !== 1'bx)?((mem_word + rt_d)& 5'h1e) : 5'b0) : 
                 ...
//最后是movz（rt_data == 0将rs_data写到rd里面否则不写，该指令mars里面有，大家可以练练），它在E级时应该也要特判阻塞，因为道理同访存（我刚开始认为它在E级就得到结果了，就和一条正常的calculate_r没有区别了），在E级得到写不写rt也会有组合逻辑延时。